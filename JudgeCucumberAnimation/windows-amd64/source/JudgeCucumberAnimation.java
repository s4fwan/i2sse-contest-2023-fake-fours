/* autogenerated by Processing revision 1282 on 2023-05-25 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class JudgeCucumberAnimation extends PApplet {



//global variables
Subject judge;
Object cucumber;
Objective desk;
HealthBar health;
SoundFile bgMusic;

float gravity = 0.5f; //
float ground;
int points;

PImage background;
PImage icon;
PImage gameOverImg;
boolean gameOver = false;

 public void settings() {
  //sets the window height to 1.5x monitor size, and makes it 16:9 aspect ratio
  size(PApplet.parseInt(displayWidth/1.5f), PApplet.parseInt((displayWidth/1.5f)/16*9));
  noSmooth(); //disables anti-aliasing (for pixel assets)
}

 public void setup() {
  //display window settings
  icon = loadImage("icon.png");
  background = loadImage("background.jpg");
  gameOverImg = loadImage("gameOver.jpg");
  surface.setTitle("Cucumber Justice");
  surface.setLocation(displayWidth/2-width/2, displayHeight/2-height/2);
  surface.setIcon(icon);
  background.resize(width, 0);
  gameOverImg.resize(width, 0);
  ground = height*8/9;
  
  //define judge of class Subject
  judge = new Subject(4, 13, 6); //animation speed, jump height, movement speed (these values can be played around with)
  
  judge.idle = loadImage("idle.png");
  judge.jump = loadImage("jump.png");
  judge.fall = loadImage("fall.png");
  judge.current = judge.idle;
  judge.running = new PImage[8];
  judge.sitting = new PImage[2];
  for(int i=0; i<judge.running.length; i++) {
    judge.running[i] = loadImage("run"+i+".png");
  }
  for(int i=0; i<judge.sitting.length; i++) {
    judge.sitting[i] = loadImage("sit"+i+".png");
  }

  judge.size = width/400;
  judge.position = new PVector((judge.size*judge.current.width)/2, ground);
  
  //cucumber
  cucumber = new Object(10, 5); //jump height, move speed
  cucumber.image = loadImage("cucumber_design.png");
  cucumber.size = width/500;
  cucumber.position = new PVector(width-cucumber.size*cucumber.image.width, ground);
  cucumber.velocity = new PVector(0, 0);
  
  //
  desk = new Objective(loadImage("desk.png"), width/400);
  health = new HealthBar();
  //
  presetSetup();
  frameRate(60);
  bgMusic = new SoundFile(this, "music.mp3");
  bgMusic.play();
}

 public void draw() {
  if(gameOver) {
    background(gameOverImg);
  }
  else {
    background(background);
    judge.update();
    judge.display();
    judge.animate();
    cucumber.update();
    cucumber.display();
    health.display();
    desk.logic();
  }
}

 public void keyPressed() {
  judge.move();
}

 public void keyReleased() {
  judge.stopMove();
}

class HealthBar {
  PVector size = new PVector(width/2, 20);
  PVector position = new PVector(width/2-size.x/2, height*0.02f);
  
   public void display() {
    rectMode(CORNER);
    fill(0,0,0, 150);
    noStroke();
    rect(position.x, position.y, size.x, size.y);
    
    float drawWidth = (judge.health/50) * size.x;
    fill(255,0,0);
    noStroke();
    rect(position.x, position.y, drawWidth, size.y);
    
    noFill();
    stroke(0);
    strokeWeight(3);
    rect(position.x, position.y, size.x, size.y);
    
    damage();
  }
  
   public void damage() {
    if(cucumber.position.x > (judge.position.x) - judge.size*judge.current.width/2 && cucumber.position.x < (judge.position.x) + judge.size*judge.current.width/2 && cucumber.position.y < (judge.position.y) + judge.size*judge.current.height/2 && cucumber.position.y > (judge.position.y) - judge.size*judge.current.height/2) {
      judge.health -= cucumber.damage;
    }
    if(judge.health <= 0) {
      gameOver = true;
    }
  }
}
class Map {
  Platform[] platforms;
  
  Map(int n) {
    platforms = new Platform[n];
  }
  
   public int platformNum() {
    return platforms.length;
  }
  
   public void display() {
    imageMode(CORNER);
    for(int i=0; i<platforms.length; i++) {
      platforms[i].display();
    }
  }
}

float oUp;
float oLeft;
float oRight;

class Object {
    PImage image;
    PVector position;
    boolean xDirection = true;
    PVector velocity;
    float jumpHeight;
    float moveSpeed;
    float size;
    int counter = 0;
    float damage = 1;
    
    Object(float jHeight, float mSpeed) {
      jumpHeight = jHeight;
      moveSpeed = mSpeed;
    }
    
     public void update() {
      if(xDirection) {
        oRight = -1;
        oLeft = 0;
      }
      else {
        oRight = 0;
        oLeft = 1;
      }
      
      //Gravity applied if above ground
      if(position.y < ground) {
        velocity.y += gravity;
      }
      else {
        velocity.y = 0;
      }
      
      //If cucumber on ground and user clicks, upward velocity is jump speed
      if(position.y >= ground && oUp != 0) {
        velocity.y = -jumpHeight;
      }
      
      velocity.x = moveSpeed * (oLeft+oRight);
      
      PVector nextPosition = new PVector(position.x, position.y);
      nextPosition.add(velocity);
      
      float offset =( size*image.width)/2;
      if(nextPosition.x > (width-offset)) {
        xDirection = !xDirection;
      }
      if(nextPosition.x < offset) {
        xDirection = !xDirection;
      }
      position.x = nextPosition.x;
      if(nextPosition.y > offset && nextPosition.y < (height-offset)) {
        position.y = nextPosition.y;
      }
      jumpAI();
    }
    
     public void display() {
      pushMatrix();
      translate(position.x, position.y);
      imageMode(CENTER);
      image(image, 0, -(size*image.height)/2, size*image.width, size*image.height);
      popMatrix();
    }
    
     public void jumpAI() {
      oUp = 0;
      int roll = PApplet.parseInt(random(0,1.9f));
      if(roll == 0 && counter > 20) {
        oUp = -1;
      }      
      if(counter > 20) {
        counter = 0;
      }
      counter++;
    }
}
class Objective {
  PImage sprite;
  PVector position;
  float size;
  float hp = 50;
  
  Objective(PImage img, float s) {
    sprite = img;
    size = s;
    position = new PVector(random(size*sprite.width/2, width-size*sprite.width/2), ground);
  }
  
   public void display() {
    imageMode(CENTER);
    image(sprite,position.x, position.y-size*sprite.height/2, size*sprite.width, size*sprite.height);
    fill(255);
    textSize(width/20);
    text(points, width/30, height/10);
  }
  
   public void progress() {
    rectMode(CENTER);
    fill(0,0,0, 150);
    noStroke();
    rect(position.x, position.y-size*sprite.height*2, size*sprite.width, size*sprite.width/10);
    
    float drawWidth = (hp/50) * size*sprite.width;
    fill(0,255,0);
    noStroke();
    rect(position.x, position.y-size*sprite.height*2, drawWidth, size*sprite.width/10);
    
    noFill();
    stroke(0);
    strokeWeight(3);
    rect(position.x, position.y-size*sprite.height*2, size*sprite.width, size*sprite.width/10);
  }
  
   public void logic() {
    display();
    if(judge.position.x > position.x-size*sprite.width/2 && judge.position.x < position.x+size*sprite.width/8 && judge.velocity.y == 0) {
      progress();
      if(keyPressed && key == 's') {
        hp -= 1;
      }
    }
    if(hp<=0) {
      hp = 50;
      points+=1;
      position.x = random(size*sprite.width/2, width-size*sprite.width/2);
    }
  }
}
class Platform {
  PImage sprite;
  PVector position;
  float size;
  boolean anim;
  
  Platform(PImage img, PVector pos, float s, boolean a) {
    sprite = img;
    position = pos;
    size = s;
    anim = a;
  }
  
   public void display() {
    imageMode(CORNER);
    image(sprite, position.x, position.y, size*sprite.width, size*sprite.height);
  }
  
   public void animate() {
    if(anim) {
    }
  }
}
//maps
PImage[] platformImg = new PImage[3];

Map map1 = new Map(5); //5
Map map2 = new Map(6);
Map map3 = new Map(3);
Map map4 = new Map(2);
Map map5 = new Map(1);

 public void presetSetup() {
  for(int i=0; i<platformImg.length; i++) {
    platformImg[i] = loadImage("platform"+i+".png");
  }
  map1.platforms[0] = new Platform(platformImg[2], new PVector(0, height/1.45f), 3, false);
  map1.platforms[1] = new Platform(platformImg[2], new PVector(width-(3*platformImg[2].width), height/1.45f), 3, false);
  map1.platforms[2] = new Platform(platformImg[0], new PVector(width/2-(platformImg[0].width*3)/2, height/2), 3, false);
  map1.platforms[3] = new Platform(platformImg[1], new PVector(2.5f*3*platformImg[1].width, height/3), 3, false);
  map1.platforms[4] = new Platform(platformImg[1], new PVector(width-(2.5f*3*platformImg[1].width)-(3*platformImg[1].width), height/3), 3, false);
}
float sUp;
float sLeft;
float sRight;

class Subject {
  PImage idle;
  PImage jump;
  PImage fall;
  PImage[] running;
  PImage[] sitting;
  PImage current;
  int currentSprite = -1;
  int counter = 0;
  int animSpeed;
  PVector position;
  PVector velocity = new PVector(0,0);
  float direction = 1;
  float jumpHeight;
  float moveSpeed;
  float size;
  float health = 50;
  
  Subject(int aSpeed, float jHeight, float mSpeed) {
    animSpeed = aSpeed;
    jumpHeight = jHeight;
    moveSpeed = mSpeed;
  }
  
   public void update() {     
    if(position.y < ground) {
      velocity.y += gravity;
    }
    else {
      velocity.y = 0;
    }
    
    if(position.y >= ground && sUp!= 0) {
      velocity.y = -jumpHeight;
    }
    
    velocity.x = moveSpeed * (sLeft+sRight);
    
    PVector nextPosition = new PVector(position.x, position.y);
    nextPosition.add(velocity);
    
    float offset = 0;
    if(nextPosition.x > offset && nextPosition.x < (width-offset)) {
      position.x = nextPosition.x;
    }
    if(nextPosition.y > offset && nextPosition.y < (height-offset)) {
      position.y = nextPosition.y;
    }
  }
  
   public void display() {
    pushMatrix();
    translate(position.x, position.y);
    scale(direction, 1);
    imageMode(CENTER);
    image(current, 0, -(size*current.height)/2, size*current.width, size*current.height);
    popMatrix();
  }
  
   public void animate() {
    if(keyPressed) {
      if(key=='a'&& counter > animSpeed) {
        if(currentSprite>running.length-2) {
          currentSprite = -1;
        }
        current = running[currentSprite+1];
        currentSprite++;
      }
      if(key=='d'&& counter > animSpeed) {
        if(currentSprite>running.length-2) {
          currentSprite = -1;
        }
        current = running[currentSprite+1];
        currentSprite++;
      }
      if(key=='s'&& counter > animSpeed) {
        if(currentSprite>sitting.length-2) {
          currentSprite = -1;
        }
        current = sitting[currentSprite+1];
        currentSprite++;
      }
    }
    if(!keyPressed && velocity.y == 0) { 
      current = idle;
      currentSprite = -1;
    }
    
    if(velocity.y < 0) {
      current = jump;
    }
    else if(velocity.y > 0) {
      current = fall;
    }
    else if(sLeft == 0 && sRight == 0 && !keyPressed) {
      current = idle;
    }
    if(counter > animSpeed) counter = 0;
    counter++;
  }
  
   public void move() {
    if(key == 'd') {
      sRight = 1;
      direction = 1;
    }
    if(key == 'a') {
      sLeft = -1;
      direction = -1;
    }
    if(key == 'w' || key == ' ') {
      sUp = -1;
    }
  }
  
   public void stopMove() {
    if(key == 'd') {
      sRight = 0;
    }
    if(key == 'a') {
      sLeft = 0;
    }
    if(key == 'w' || key == ' ') {
      sUp = 0;
    }
  }
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "JudgeCucumberAnimation" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
